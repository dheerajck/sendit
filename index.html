<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SendIt - P2P Thing</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --bg-primary: #121212;
      --bg-secondary: #1f1f1f;
      --bg-tertiary: #2d2d2d;
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --accent: #8c52ff;
      --accent-hover: #a375ff;
      --error: #ff5252;
      --success: #4caf50;
      --border-radius: 8px;
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      --transition: all 0.3s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      padding: 0;
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      width: 100%;
      max-width: 800px;
      padding: 20px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 20px 0;
      margin-bottom: 20px;
    }

    .logo {
      font-size: 2.5rem;
      font-weight: bold;
      margin-bottom: 5px;
      color: var(--accent);
    }

    .tagline {
      color: var(--text-secondary);
      font-size: 1rem;
    }

    .card {
      background-color: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: var(--card-shadow);
    }

    h2 {
      color: var(--text-primary);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      font-size: 1.2rem;
    }

    h2 i {
      margin-right: 10px;
      color: var(--accent);
    }

    input, textarea {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      background-color: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid #444;
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
    }

    input:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(140, 82, 255, 0.2);
    }

    .btn {
      padding: 12px 16px;
      background-color: var(--accent);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .btn i {
      margin-right: 8px;
    }

    .btn:hover {
      background-color: var(--accent-hover);
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .peer-id-display {
      background-color: var(--bg-tertiary);
      padding: 15px;
      border-radius: var(--border-radius);
      margin: 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .peer-id-value {
      font-weight: bold;
      color: var(--accent);
    }

    .copy-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 5px;
      transition: var(--transition);
    }

    .copy-btn:hover {
      color: var(--accent);
    }

    .message-container {
      border: 1px solid #444;
      border-radius: var(--border-radius);
      height: 300px;
      overflow-y: auto;
      padding: 10px;
      background-color: var(--bg-tertiary);
      margin-top: 15px;
    }

    .message {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: var(--border-radius);
      max-width: 80%;
      word-break: break-word;
    }

    .message-time {
      font-size: 0.8rem;
      color: var(--text-secondary);
      margin-top: 5px;
    }

    .message.received {
      background-color: #2a2a2a;
      align-self: flex-start;
      border-bottom-left-radius: 0;
    }

    .message.sent {
      background-color: var(--accent);
      align-self: flex-end;
      margin-left: auto;
      border-bottom-right-radius: 0;
    }

    .message-form {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .message-input {
      flex-grow: 1;
      margin: 0;
    }

    .connection-status {
      font-size: 0.9rem;
      padding: 6px 12px;
      border-radius: 20px;
      display: inline-flex;
      align-items: center;
      margin-bottom: 15px;
    }

    .status-disconnected {
      background-color: rgba(255, 82, 82, 0.2);
      color: #ff5252;
    }

    .status-connected {
      background-color: rgba(76, 175, 80, 0.2);
      color: #4caf50;
    }

    .status-icon {
      margin-right: 6px;
      font-size: 0.8rem;
    }

    .messages {
      display: flex;
      flex-direction: column;
    }

    .system-message {
      text-align: center;
      color: var(--text-secondary);
      margin: 10px 0;
      font-style: italic;
      font-size: 0.9rem;
    }

    .tabs {
      display: flex;
      margin-bottom: 15px;
    }

    .tab {
      flex: 1;
      text-align: center;
      padding: 10px;
      background-color: var(--bg-tertiary);
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: var(--transition);
    }

    .tab.active {
      border-bottom-color: var(--accent);
      color: var(--accent);
    }

    .tab:hover:not(.active) {
      background-color: #353535;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .input-group {
      position: relative;
      margin-bottom: 15px;
    }

    .input-error {
      color: var(--error);
      font-size: 0.85rem;
      margin-top: 5px;
      display: none;
    }

    .input-error.visible {
      display: block;
    }

    .room-display {
      background-color: var(--bg-tertiary);
      padding: 15px;
      border-radius: var(--border-radius);
      margin: 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .room-code {
      font-weight: bold;
      color: var(--accent);
    }

    .user-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--bg-secondary);
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      box-shadow: var(--card-shadow);
      z-index: 10;
    }

    .user-avatar {
      width: 24px;
      height: 24px;
      background-color: var(--accent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
    }

    .sender-name {
      font-weight: bold;
      margin-right: 6px;
      color: var(--accent);
    }

    /* Screen sharing styles */
    .screen-container {
      position: relative;
      width: 100%;
      background-color: var(--bg-tertiary);
      border-radius: var(--border-radius);
      margin-bottom: 15px;
      overflow: hidden;
    }

    .screen-video {
      width: 100%;
      display: block;
    }

    .screen-controls {
      padding: 10px;
      background-color: var(--bg-tertiary);
      border-radius: 0 0 var(--border-radius) var(--border-radius);
      display: flex;
      justify-content: space-between;
    }

    .screen-placeholder {
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    .btn-danger {
      background-color: var(--error);
    }

    .btn-danger:hover {
      background-color: #ff7575;
    }

    .share-options {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .mini-tab {
      border-radius: var(--border-radius);
      padding: 5px 10px;
      background-color: var(--bg-tertiary);
      cursor: pointer;
      font-size: 0.9rem;
      transition: var(--transition);
    }

    .mini-tab.active {
      background-color: var(--accent);
      color: white;
    }

    .screen-sharing-notice {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: var(--error);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      animation: pulse 2s infinite;
      z-index: 5;
    }

    .screen-sharing-notice i {
      margin-right: 5px;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
      100% {
        opacity: 1;
      }
    }

    @media (max-width: 600px) {
      .btn-group {
        flex-direction: column;
      }

      .message {
        max-width: 90%;
      }

      .tabs {
        flex-direction: column;
      }
    }

    /* Audio sharing styles */
    .audio-container {
      position: relative;
      width: 100%;
      background-color: var(--bg-tertiary);
      border-radius: var(--border-radius);
      margin-bottom: 15px;
      overflow: hidden;
    }

    .audio-placeholder {
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    .audio-controls {
      padding: 10px;
      background-color: var(--bg-tertiary);
      border-radius: 0 0 var(--border-radius) var(--border-radius);
      display: flex;
      justify-content: space-between;
    }

    .audio-sharing-notice {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: var(--accent);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      animation: pulse 2s infinite;
      z-index: 5;
    }

    .audio-sharing-notice i {
      margin-right: 5px;
    }

    .audio-visualizer {
      height: 80px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }

    .audio-bar {
      background-color: var(--accent);
      width: 4px;
      height: 10px;
      margin: 0 2px;
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    /* Online Users Panel Styles */
    .online-users-panel {
      position: absolute;
      top: 60px; /* Adjust as needed below user-info */
      right: -220px; /* Position outside the main card */
      width: 200px;
      background-color: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 15px;
      box-shadow: var(--card-shadow);
      max-height: 400px; /* Limit height */
      overflow-y: auto; /* Add scroll if list is long */
    }

    .online-users-panel h4 {
      color: var(--accent);
      margin-bottom: 10px;
      font-size: 1rem;
      border-bottom: 1px solid var(--bg-tertiary);
      padding-bottom: 5px;
      display: flex;
      align-items: center;
    }
    .online-users-panel h4 i {
       margin-right: 8px;
    }


    .online-users-panel ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .online-users-panel li {
      padding: 5px 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
      border-bottom: 1px dashed var(--bg-tertiary);
    }
     .online-users-panel li:last-child {
       border-bottom: none;
     }

    .online-users-panel li .you-indicator {
      font-style: italic;
      color: var(--success);
      font-size: 0.8rem;
      margin-left: 5px;
    }


    @media (max-width: 1050px) { /* Adjust breakpoint as needed */
      .online-users-panel {
        position: static; /* Stack below on smaller screens */
        width: 100%;
        margin-top: 20px;
        right: auto;
        max-height: 150px; /* Adjust height for stacked view */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">SendIt</div>
      <p class="tagline">Secure P2P thing for desktop browser</p>
    </header>

    <div id="setup-card" class="card">
      <div class="connection-status status-disconnected">
        <span class="status-icon"><i class="fas fa-circle"></i></span>
        <span id="connection-text">Not connected</span>
      </div>

      <div class="tabs">
        <div class="tab active" id="create-tab" onclick="switchTab('create')">
          <i class="fas fa-plus-circle"></i> Create Room
        </div>
        <div class="tab" id="join-tab" onclick="switchTab('join')">
          <i class="fas fa-sign-in-alt"></i> Join Room
        </div>
      </div>

      <div id="create-content" class="tab-content active">
        <h2><i class="fas fa-user-plus"></i> Create a Room</h2>
        <div class="input-group">
          <input id="host-username" placeholder="Enter your username (e.g. alex123)">
          <div id="username-error" class="input-error">This username is already taken</div>
        </div>
        <button class="btn" onclick="createRoom()">
          <i class="fas fa-door-open"></i> Create Room
        </button>

        <div id="room-info" style="display: none;">
          <div class="room-display">
            <div>
              <div>Room Code:</div>
              <div class="room-code" id="room-code">Not created yet</div>
            </div>
            <button class="copy-btn" onclick="copyRoomCode()">
              <i class="fas fa-copy"></i>
            </button>
          </div>
          <p>Share this code with others to let them join your room</p>
        </div>
      </div>

      <div id="join-content" class="tab-content">
        <h2><i class="fas fa-sign-in-alt"></i> Join a Room</h2>
        <div class="input-group">
          <input id="guest-username" placeholder="Enter your username (optional)">
        </div>
        <div class="input-group">
          <input id="room-code-input" placeholder="Enter room code">
        </div>
        <button class="btn" onclick="joinRoom()">
          <i class="fas fa-door-open"></i> Join Room
        </button>
      </div>
    </div>

    <div id="chat-card" class="card" style="display: none; position: relative;"> <!-- Added position: relative -->

      <!-- Online Users Panel -->
      <div id="online-users-panel" class="online-users-panel" style="display: none;"> <!-- Initially hidden -->
        <h4><i class="fas fa-users"></i> Online Users</h4>
        <ul id="online-users-list">
          <!-- User list will be populated here -->
        </ul>
      </div>

      <div id="user-info" class="user-info">
        <div class="user-avatar">
          <i class="fas fa-user"></i>
        </div>
        <span id="display-username">Not Set</span>
      </div>

      <!-- Screen Sharing Card -->
      <div id="screen-sharing-card" class="card">
        <h2><i class="fas fa-desktop"></i> Screen Sharing</h2>

        <div class="screen-container" id="screen-container">
          <div id="screen-placeholder" class="screen-placeholder">
            <div>No screen is being shared</div>
          </div>
          <video id="shared-screen" class="screen-video" autoplay playsinline style="display: none;"></video>
          <div id="screen-sharing-notice" class="screen-sharing-notice" style="display: none;">
            <i class="fas fa-broadcast-tower"></i> You are sharing your screen
          </div>
        </div>

        <div class="screen-controls">
          <button class="btn" id="start-share-btn" onclick="startScreenShare()">
            <i class="fas fa-share-square"></i> Share Screen
          </button>
          <button class="btn btn-danger" id="stop-share-btn" onclick="stopScreenShare()" style="display: none;">
            <i class="fas fa-stop-circle"></i> Stop Sharing
          </button>
        </div>
      </div>

      <!-- Audio Sharing Card -->
      <div id="audio-sharing-card" class="card">
        <h2><i class="fas fa-microphone"></i> Audio Sharing</h2>

        <div class="audio-container">
          <div id="audio-placeholder" class="audio-placeholder">
            <div>No audio is being shared</div>
          </div>
          <audio id="shared-audio" autoplay playsinline style="display: none;"></audio>
          <div id="audio-sharing-notice" class="audio-sharing-notice" style="display: none;">
            <i class="fas fa-broadcast-tower"></i> You are sharing your audio
          </div>
        </div>

        <div class="audio-controls">
          <button class="btn" id="start-audio-btn" onclick="startAudioShare()">
            <i class="fas fa-microphone"></i> Share Audio
          </button>
          <button class="btn btn-danger" id="stop-audio-btn" onclick="stopAudioShare()" style="display: none;">
            <i class="fas fa-microphone-slash"></i> Stop Sharing
          </button>
        </div>
      </div>

      <h2><i class="fas fa-comment-alt"></i> Messages</h2>
      <div class="message-container" id="messages">
        <div class="messages"></div>
      </div>

      <div class="message-form">
        <input id="message" class="message-input" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
        <button class="btn" onclick="sendMessage()">
          <i class="fas fa-paper-plane"></i> Send
        </button>
      </div>

      <div class="file-share-form" style="margin-top:15px; display:flex; gap:10px;">
        <input type="file" id="file-input" style="flex:1;">
        <button class="btn" onclick="sendFile()">
          <i class="fas fa-upload"></i> Send File
        </button>
      </div>
      <div id="file-progress" style="margin-top:10px; color:var(--accent); display:none;"></div>

      <button class="btn" style="margin-top: 10px;" onclick="leaveRoom()">
        <i class="fas fa-sign-out-alt"></i> Leave Room
      </button>
    </div>
  </div>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
let peer = null;
let connections = []; // Array to store all connections (host and guests)
let username = '';
let isRoomCreator = false;
let localStream = null;
let shareOption = 'entire-screen';
let peersInfo = []; // <-- Add this line: Stores { peerId: string, username: string }

// Screen share variables
let isScreenSharing = false;
let screenSharingPeerId = null;

// Audio share variables
let audioStream = null;
let isAudioSharing = false;
let audioSharingPeerId = null;
let audioContext = null;
let audioAnalyser = null;
let audioVisualizerInterval = null;

// File sharing variables
const incomingFiles = {}; // { senderId: {chunks: [], info: {}} }

function switchTab(tabName) {
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.getElementById(`${tabName}-content`).classList.add('active');
  document.getElementById(`${tabName}-tab`).classList.add('active');
}

// function selectShareOption(option) {
//   shareOption = option;
//   document.querySelectorAll('.mini-tab').forEach(tab => {
//     tab.classList.remove('active');
//   });
//   document.getElementById(`${option}-tab`).classList.add('active');
// }

async function startScreenShare() {
  if (isScreenSharing) return;

  try {
    let displayMediaOptions = { video: true, audio: true };

    // Apply different constraints based on selected option
    if (shareOption === 'entire-screen') {
      displayMediaOptions = { video: { displaySurface: 'monitor' }, audio: true };
    } else if (shareOption === 'window') {
      displayMediaOptions = { video: { displaySurface: 'window' }, audio: true };
    } else if (shareOption === 'tab') {
      displayMediaOptions = { video: { displaySurface: 'browser' }, audio: true };
    }

    localStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);

    // Display local stream
    const sharedScreen = document.getElementById('shared-screen');
    document.getElementById('screen-placeholder').style.display = 'none';
    sharedScreen.style.display = 'block';
    sharedScreen.srcObject = localStream;

    // Show screen sharing notice
    document.getElementById('screen-sharing-notice').style.display = 'flex';

    // Toggle buttons
    document.getElementById('start-share-btn').style.display = 'none';
    document.getElementById('stop-share-btn').style.display = 'inline-flex';

    isScreenSharing = true;
    screenSharingPeerId = peer.id;

    // Create a video call to EACH peer
    connections.forEach(conn => {
      if (conn.open) {
        // First notify peers that screen sharing is starting
        conn.send({
          type: 'screenShareStarting',
          peerId: peer.id,
          username: username
        });

        // Then call them with the video stream
        const call = peer.call(conn.peer, localStream, { metadata: { type: 'screenShare', username } });
        setupCallEvents(call);
      }
    });

    // Listen for stream end events
    localStream.getVideoTracks()[0].addEventListener('ended', () => {
      stopScreenShare();
    });

    addSystemMessage('You started sharing your screen');
  } catch (err) {
    console.error('Error starting screen share:', err);
    addSystemMessage('Failed to share screen: ' + err.message);
  }
}

function stopScreenShare(broadcast = true) {
  if (!isScreenSharing || !localStream) return;

  // Stop all tracks
  localStream.getTracks().forEach(track => track.stop());
  localStream = null;

  // Update UI
  document.getElementById('shared-screen').style.display = 'none';
  document.getElementById('shared-screen').srcObject = null;
  document.getElementById('screen-placeholder').style.display = 'flex';
  document.getElementById('screen-sharing-notice').style.display = 'none';
  document.getElementById('start-share-btn').style.display = 'inline-flex';
  document.getElementById('stop-share-btn').style.display = 'none';

  isScreenSharing = false;

  // Notify all peers that screen sharing has stopped
  if (broadcast) {
    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'screenShareStopped',
          peerId: peer.id,
          username: username
        });
      }
    });
    addSystemMessage('You stopped sharing your screen');
  }
   screenSharingPeerId = null; // Clear regardless of broadcast
}

// Setup call events for both initiator and receiver (SCREEN)
function setupCallEvents(call) {
  call.on('stream', (remoteStream) => {
    // Display the remote stream if it's a screen share
    if (call.metadata?.type === 'screenShare') {
      const sharedScreen = document.getElementById('shared-screen');
      document.getElementById('screen-placeholder').style.display = 'none';
      sharedScreen.style.display = 'block';
      sharedScreen.srcObject = remoteStream;
      screenSharingPeerId = call.peer;

      addSystemMessage(`${call.metadata.username || 'Someone'} is sharing their screen`);
    }
  });

  call.on('close', () => {
    if (call.metadata?.type === 'screenShare' && screenSharingPeerId === call.peer) {
      document.getElementById('shared-screen').style.display = 'none';
      document.getElementById('shared-screen').srcObject = null;
      document.getElementById('screen-placeholder').style.display = 'flex';
      screenSharingPeerId = null;

      addSystemMessage(`${call.metadata.username || 'Someone'} stopped sharing their screen`);
    }
  });

  call.on('error', (err) => {
    console.error('Call error:', err);
    addSystemMessage('Screen sharing error: ' + err.message);
  });
}

// --- Add this function ---
// Setup call events for both initiator and receiver (AUDIO)
function setupAudioCallEvents(call) {
  call.on('stream', (remoteStream) => {
    // Play the remote audio stream
    if (call.metadata?.type === 'audioShare') {
      const sharedAudio = document.getElementById('shared-audio');
      document.getElementById('audio-placeholder').style.display = 'none';
      sharedAudio.style.display = 'block'; // Make sure audio element is visible if needed for controls
      sharedAudio.srcObject = remoteStream;
      audioSharingPeerId = call.peer; // Track who is sharing audio

      // Optional: Create visualizer for received audio (more complex)
      // createReceivedAudioVisualizer(remoteStream);

      addSystemMessage(`${call.metadata.username || 'Someone'} is sharing their audio`);
    }
  });

  call.on('close', () => {
    // Clean up when the audio call ends
    if (call.metadata?.type === 'audioShare' && audioSharingPeerId === call.peer) {
      cleanupAudioShare(call.peer, call.metadata.username || 'Someone', 'stopped sharing');
    }
  });

  call.on('error', (err) => {
    console.error('Audio call error:', err);
    addSystemMessage(`Audio sharing error with ${call.metadata.username || 'peer'}: ${err.message}`);
    // Clean up on error as well
    if (call.metadata?.type === 'audioShare' && audioSharingPeerId === call.peer) {
      cleanupAudioShare(call.peer, call.metadata.username || 'Someone', 'had an error');
    }
  });
}
// --- End of added function ---

async function startAudioShare() {
  if (isAudioSharing) return;

  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    // Show audio sharing notice
    document.getElementById('audio-sharing-notice').style.display = 'flex';
    document.getElementById('audio-placeholder').style.display = 'none';

    // Create audio visualizer for local stream
    createLocalAudioVisualizer(); // Renamed for clarity

    // Toggle buttons
    document.getElementById('start-audio-btn').style.display = 'none';
    document.getElementById('stop-audio-btn').style.display = 'inline-flex';

    isAudioSharing = true;
    audioSharingPeerId = peer.id; // Mark self as sharing

    // Create an audio call to EACH peer
    connections.forEach(conn => {
      if (conn.open) {
        // First notify peers that audio sharing is starting
        conn.send({
          type: 'audioShareStarting',
          peerId: peer.id,
          username: username
        });

        // Then call them with the audio stream
        const call = peer.call(conn.peer, audioStream, { metadata: { type: 'audioShare', username } });
        setupAudioCallEvents(call); // Setup handlers for the outgoing call object
      }
    });

    addSystemMessage('You started sharing your audio');
  } catch (err) {
    console.error('Error starting audio share:', err);
    addSystemMessage('Failed to share audio: ' + err.message);
  }
}

// --- Rename createAudioVisualizer for clarity ---
function createLocalAudioVisualizer() {
    if (!audioStream || audioContext) return; // Don't create if no stream or context exists

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioAnalyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(audioStream);
        source.connect(audioAnalyser);
        // Note: We don't connect analyser to destination for local visualization

        audioAnalyser.fftSize = 128; // Smaller size for fewer bars
        const bufferLength = audioAnalyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const visualizerContainer = document.getElementById('audio-container'); // Place inside the container
        let visualizer = document.getElementById('audio-visualizer');
        if (visualizer) visualizer.remove(); // Remove old one if exists

        visualizer = document.createElement('div');
        visualizer.id = 'audio-visualizer';
        visualizer.className = 'audio-visualizer';
        visualizerContainer.insertBefore(visualizer, visualizerContainer.firstChild); // Add visualizer at the top

        for (let i = 0; i < bufferLength; i++) {
            const bar = document.createElement('div');
            bar.className = 'audio-bar';
            visualizer.appendChild(bar);
        }

        const bars = visualizer.getElementsByClassName('audio-bar');

        function drawVisualizer() {
            if (!audioContext || !audioAnalyser) {
                clearInterval(audioVisualizerInterval);
                return;
            }
            audioAnalyser.getByteFrequencyData(dataArray);
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = Math.max(10, (dataArray[i] / 255) * 60); // Min height 10, max 60
                if (bars[i]) {
                    bars[i].style.height = `${barHeight}px`;
                }
            }
        }

        if (audioVisualizerInterval) clearInterval(audioVisualizerInterval);
        audioVisualizerInterval = setInterval(drawVisualizer, 50); // Update rate

    } catch (e) {
        console.error("Error creating local audio visualizer:", e);
        addSystemMessage("Could not create audio visualizer.");
        if (audioContext) audioContext.close().catch(err => console.error("Error closing context:", err));
        audioContext = null;
        audioAnalyser = null;
    }
}
// --- End of renamed function ---

function stopAudioShare(broadcast = true) {
  if (!isAudioSharing || !audioStream) return;

  // Stop all tracks
  audioStream.getTracks().forEach(track => track.stop());
  audioStream = null;

  // Clean up audio context if it exists
  if (audioContext) {
    clearInterval(audioVisualizerInterval);
    audioContext.close().catch(e => console.error("Error closing audio context:", e));
    audioContext = null;
    audioAnalyser = null;
  }

  // Update UI
  document.getElementById('audio-sharing-notice').style.display = 'none';
  document.getElementById('audio-placeholder').style.display = 'flex';
  document.getElementById('audio-placeholder').innerHTML = '<div>No audio is being shared</div>'; // Reset placeholder text
  document.getElementById('start-audio-btn').style.display = 'inline-flex';
  document.getElementById('stop-audio-btn').style.display = 'none';

  // Remove visualizer if it exists
  const visualizer = document.getElementById('audio-visualizer');
  if (visualizer) {
    visualizer.remove();
  }

  isAudioSharing = false;

  // Notify all peers that audio sharing has stopped
  if (broadcast) {
    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'audioShareStopped',
          peerId: peer.id,
          username: username
        });
      }
    });
    addSystemMessage('You stopped sharing your audio');
  }
  audioSharingPeerId = null; // Clear regardless of broadcast
}


// File sending
function sendFile() {
  const fileInput = document.getElementById('file-input');
  const file = fileInput.files[0];
  if (!file) {
    addSystemMessage('No file selected.');
    return;
  }

  const chunkSize = 256 * 1024; // 256KB per chunk for better speed
  const totalChunks = Math.ceil(file.size / chunkSize);
  let offset = 0;
  let chunkIndex = 0;

  document.getElementById('file-progress').style.display = 'block';
  document.getElementById('file-progress').textContent = `Sending: ${file.name} (0%)`;

  function sendNextChunk() {
    const reader = new FileReader();
    const slice = file.slice(offset, offset + chunkSize);
    reader.onload = function(e) {
      const chunk = e.target.result;
      // Send chunk to all peers
      connections.forEach(conn => {
        if (conn.open) {
          // Flow control: wait if buffer is too full
          if (conn._dc && conn._dc.bufferedAmount > 2 * chunk.byteLength) {
            setTimeout(() => conn.send({
              type: 'file-chunk',
              fileName: file.name,
              fileType: file.type,
              totalSize: file.size,
              chunkIndex,
              totalChunks,
              data: chunk
            }), 10);
          } else {
            conn.send({
              type: 'file-chunk',
              fileName: file.name,
              fileType: file.type,
              totalSize: file.size,
              chunkIndex,
              totalChunks,
              data: chunk
            });
          }
        }
      });
      offset += chunkSize;
      chunkIndex++;
      const percent = Math.floor((offset / file.size) * 100);
      document.getElementById('file-progress').textContent = `Sending: ${file.name} (${percent}%)`;
      if (offset < file.size) {
        sendNextChunk();
      } else {
        document.getElementById('file-progress').textContent = `Sent: ${file.name}`;
        setTimeout(() => {
          document.getElementById('file-progress').style.display = 'none';
        }, 2000);
      }
    };
    reader.readAsArrayBuffer(slice);
  }
  sendNextChunk();
}

// File receiving
function handleFileChunk(data, senderId) { // <-- Use senderId parameter
  if (!incomingFiles[senderId]) {
    incomingFiles[senderId] = {};
  }
  const key = data.fileName + data.totalSize; // Use filename + size as key for a specific file from a sender
  if (!incomingFiles[senderId][key]) {
    incomingFiles[senderId][key] = {
      chunks: [],
      info: { // Store file info separately
         fileName: data.fileName,
         fileType: data.fileType,
         totalSize: data.totalSize,
         totalChunks: data.totalChunks
      },
      receivedChunks: 0,
      receivedSize: 0
    };
     addSystemMessage(`Receiving file: ${data.fileName} from ${peersInfo.find(p=>p.peerId === senderId)?.username || 'user'}...`);
  }

  const fileObj = incomingFiles[senderId][key];

  // Only store chunk if not already received (simple check)
  if (!fileObj.chunks[data.chunkIndex]) {
      fileObj.chunks[data.chunkIndex] = data.data;
      fileObj.receivedChunks++;
      fileObj.receivedSize += data.data.byteLength;

      // Progress display
      const percent = Math.floor((fileObj.receivedSize / fileObj.info.totalSize) * 100);
      // Update a dedicated progress element or use system messages less frequently
      // Example: updateProgressUI(senderId, key, percent);
      if (fileObj.receivedChunks % 10 === 0 || fileObj.receivedChunks === fileObj.info.totalChunks) { // Update progress less often
         addSystemMessage(`Receiving ${fileObj.info.fileName}: ${percent}% (${fileObj.receivedChunks}/${fileObj.info.totalChunks})`);
      }


      if (fileObj.receivedChunks === fileObj.info.totalChunks) {
        // Ensure all chunks are present (check for gaps)
        let complete = true;
        for(let i = 0; i < fileObj.info.totalChunks; i++) {
            if (!fileObj.chunks[i]) {
                complete = false;
                console.error(`Missing chunk ${i} for file ${fileObj.info.fileName} from ${senderId}`);
                addSystemMessage(`Error receiving ${fileObj.info.fileName}: Missing chunk ${i}. Please ask sender to resend.`);
                // TODO: Implement chunk request logic if needed
                break;
            }
        }

        if (complete) {
            // Assemble file
            addSystemMessage(`Assembling ${fileObj.info.fileName}...`);
            try {
                const blob = new Blob(fileObj.chunks, { type: fileObj.info.fileType });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = fileObj.info.fileName;

                const icon = document.createElement('i');
                icon.className = 'fas fa-download';
                link.appendChild(icon);
                link.appendChild(document.createTextNode(` Download ${fileObj.info.fileName} (${(fileObj.info.totalSize / 1024 / 1024).toFixed(2)} MB)`));

                const messageDiv = document.createElement('div');
                messageDiv.className = 'message system-message'; // Style as a system message or custom file message
                messageDiv.appendChild(link);

                document.querySelector('.messages').appendChild(messageDiv);
                scrollToBottom();
                addSystemMessage(`File ${fileObj.info.fileName} received successfully!`);
            } catch (error) {
                console.error("Error creating blob or download link:", error);
                addSystemMessage(`Failed to process received file ${fileObj.info.fileName}.`);
            } finally {
                 // Clean up memory
                 delete incomingFiles[senderId][key];
                 if (Object.keys(incomingFiles[senderId]).length === 0) {
                     delete incomingFiles[senderId];
                 }
            }
        } else {
             // Handle incomplete file (e.g., notify user, maybe delete partial data)
             addSystemMessage(`File ${fileObj.info.fileName} is incomplete. Cannot assemble.`);
             // Optionally delete: delete incomingFiles[senderId][key];
        }
      }
  } else {
     console.warn(`Received duplicate chunk ${data.chunkIndex} for ${data.fileName} from ${senderId}`);
  }
}

function createRoom() {
  username = document.getElementById('host-username').value.trim();
  if (!username) {
    document.getElementById('username-error').textContent = 'Please enter a username';
    document.getElementById('username-error').classList.add('visible');
    return;
  }
  // Clear previous error
  document.getElementById('username-error').classList.remove('visible');

  isRoomCreator = true;

  if (peer) {
    peer.destroy();
  }
  peersInfo = []; // Reset peers list
  connections = []; // Reset connections

  const roomCode = username; // Use username as room code for simplicity here
  peer = new Peer(roomCode, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });

  peer.on('open', (id) => {
    document.getElementById('room-code').textContent = roomCode;
    document.getElementById('room-info').style.display = 'block';
    document.getElementById('display-username').textContent = username;
    addSystemMessage(`Room created! Your room code: ${roomCode}`);
    updateConnectionStatus('waiting');

    // Add host to the list
    peersInfo = [{ peerId: id, username: username }];
    updateOnlineUsersList(); // Update UI

    document.getElementById('setup-card').style.display = 'none'; // Hide setup
    document.getElementById('chat-card').style.display = 'block'; // Show chat
  });

  peer.on('error', (err) => {
    if (err.type === 'unavailable-id') {
      document.getElementById('username-error').textContent = 'Username already taken. Try another.';
      document.getElementById('username-error').classList.add('visible');
      // Reset state if creation failed
      if (peer) peer.destroy();
      peer = null;
      peersInfo = [];
      updateOnlineUsersList();
      document.getElementById('setup-card').style.display = 'block';
      document.getElementById('chat-card').style.display = 'none';
    } else {
      addSystemMessage(`Error: ${err.type} - ${err.message}`);
    }
    updateConnectionStatus('error');
  });

  peer.on('connection', (connection) => {
    // Check if already connected to this peer
     if (connections.some(c => c.peer === connection.peer)) {
        connection.close();
        return;
     }

    const guestUsername = connection.metadata?.username || 'Guest';
    const guestPeerId = connection.peer;

    // Add guest to host's list *before* setting up handlers
    // to ensure the list is up-to-date when sending
    if (!peersInfo.some(p => p.peerId === guestPeerId)) {
        peersInfo.push({ peerId: guestPeerId, username: guestUsername });
        updateOnlineUsersList(); // Update host's UI immediately
    }


    connection.on('open', () => {
        // Send the current full list of peers to the new guest
        connection.send({
          type: 'peerList',
          peers: peersInfo // Send the updated list
        });

        // Notify *other* existing peers about the new guest (using peerList is better)
        broadcastPeerList(); // Send updated list to everyone

        // Now add the connection and set it up
        if (!connections.some(c => c.peer === connection.peer)) {
            connections.push(connection);
        }
        setupConnection(connection); // Setup handlers
        addSystemMessage(`${guestUsername} has joined the room!`);
        updateConnectionStatus('connected');
    });

    // --- Add close handler specific to host's perspective ---
    connection.on('close', () => {
        const closedPeerInfo = peersInfo.find(p => p.peerId === connection.peer);
        const closedUsername = closedPeerInfo?.username || 'A user';
        addSystemMessage(`${closedUsername} (${connection.peer}) has left the room.`);

        // Remove from host's connections array
        connections = connections.filter(conn => conn.peer !== connection.peer);
        // Remove from host's peersInfo array
        peersInfo = peersInfo.filter(p => p.peerId !== connection.peer);
        updateOnlineUsersList(); // Update host's UI

        // Broadcast the updated list to all remaining peers
        broadcastPeerList();

        updateConnectionStatus(connections.length > 0 ? 'connected' : 'waiting');

        // Clean up media if the disconnected peer was sharing
        cleanupMediaForPeer(connection.peer, closedUsername);
    });

    // --- Add error handler specific to host's perspective ---
    connection.on('error', (err) => {
        const errorPeerInfo = peersInfo.find(p => p.peerId === connection.peer);
        const errorUsername = errorPeerInfo?.username || 'A user';
        addSystemMessage(`Connection error with ${errorUsername} (${connection.peer}): ${err.type}. Removing user.`);

        // Remove from host's connections array
        connections = connections.filter(conn => conn.peer !== connection.peer);
        // Remove from host's peersInfo array
        peersInfo = peersInfo.filter(p => p.peerId !== connection.peer);
        updateOnlineUsersList(); // Update host's UI

        // Broadcast the updated list to all remaining peers
        broadcastPeerList();

        updateConnectionStatus(connections.length > 0 ? 'connected' : 'waiting');
        cleanupMediaForPeer(connection.peer, errorUsername);
    });
    // --- End of host-specific handlers ---

  });

  // Handle incoming calls (for screen sharing and audio sharing)
  peer.on('call', (call) => {
    // Check call metadata to handle differently based on type
    const callType = call.metadata?.type || 'unknown';

    if (callType === 'screenShare' || callType === 'audioShare') {
      // Answer without sending a stream back for screen and audio shares
      call.answer(); // Answer the call

      if (callType === 'screenShare') {
        setupCallEvents(call); // Setup for screen share stream
      } else if (callType === 'audioShare') {
        setupAudioCallEvents(call); // Setup for audio share stream
      }
    } else {
       console.warn("Received unknown call type:", callType);
       // Optionally reject or ignore
    }
  });
}

// --- Add a helper function for the host to broadcast the list ---
function broadcastPeerList() {
    if (!isRoomCreator) return; // Only host broadcasts the full list

    connections.forEach(conn => {
        if (conn.open) {
            conn.send({
                type: 'peerList',
                peers: peersInfo
            });
        }
    });
    console.log("Host broadcasted updated peer list:", peersInfo);
}
// --- End of helper function ---

function joinRoom() {
  const roomCode = document.getElementById('room-code-input').value.trim();
  if (!roomCode) {
    addSystemMessage('Please enter a room code.'); // Consider adding UI feedback too
    return;
  }

  username = document.getElementById('guest-username').value.trim();
  if (!username) {
    username = 'Guest' + Math.floor(Math.random() * 1000);
  }

  document.getElementById('display-username').textContent = username;

  if (peer) {
    peer.destroy();
  }
  peersInfo = []; // Reset peers list
  connections = []; // Reset connections

  // Use a unique ID for the guest to avoid collisions if multiple guests have the same name
  const guestPeerId = `guest_${username}_${Math.random().toString(16).substring(2, 8)}`;
  peer = new Peer(guestPeerId, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });

  peer.on('open', (id) => {
    addSystemMessage(`Attempting to join room: ${roomCode}...`);
    updateConnectionStatus('connecting');

    // Connect to the host (identified by roomCode/host username)
    const hostConnection = peer.connect(roomCode, {
      metadata: { username: username },
      reliable: true // Ensure reliable connection for initial setup messages
    });

    // Setup handlers specifically for the host connection first
    setupHostConnection(hostConnection);

  });

   // Handle direct connections from other peers (initiated by host or other peers based on peerList)
  peer.on('connection', (connection) => {
     // Avoid connecting to self or duplicates
     if (connection.peer === peer.id || connections.some(c => c.peer === connection.peer)) {
        connection.close();
        return;
     }
     console.log(`Incoming connection from peer: ${connection.peer}`);
     connections.push(connection); // Add to general connections list
     setupConnection(connection); // Use the general setup
  });


  // Handle incoming calls (for screen sharing and audio sharing)
  peer.on('call', (call) => {
    // Check call metadata to handle differently based on type
    const callType = call.metadata?.type || 'unknown';

    if (callType === 'screenShare' || callType === 'audioShare') {
      // Answer without sending a stream back for screen and audio shares
      call.answer(); // Answer the call

      if (callType === 'screenShare') {
        setupCallEvents(call); // Setup for screen share stream
      } else if (callType === 'audioShare') {
        setupAudioCallEvents(call); // Setup for audio share stream
      }
    } else {
       console.warn("Received unknown call type:", callType);
       // Optionally reject or ignore
    }
  });

  peer.on('error', (err) => {
    addSystemMessage(`Error: ${err.type} - ${err.message}`);
    if (err.type === 'peer-unavailable') {
      addSystemMessage(`Could not connect to room "${roomCode}". Check the code or the host might not be available.`);
    }
    updateConnectionStatus('error');
    // Clean up if connection failed
    if(peer) peer.destroy();
    peer = null;
    peersInfo = [];
    updateOnlineUsersList();
    document.getElementById('setup-card').style.display = 'block';
    document.getElementById('chat-card').style.display = 'none';
  });
}

// Special setup for the initial connection *to the host* by a guest
function setupHostConnection(hostConnection) {
    hostConnection.on('open', () => {
        addSystemMessage('Connected to host! Waiting for peer list...');
        updateConnectionStatus('connected'); // Tentative status
        document.getElementById('setup-card').style.display = 'none';
        document.getElementById('chat-card').style.display = 'block';
        // Add host connection to the list *only if not already present*
        if (!connections.some(c => c.peer === hostConnection.peer)) {
            connections.push(hostConnection);
        }
    });

    hostConnection.on('data', (data) => {
        if (data.type === 'peerList') {
            // This is the primary way guests get the list
            const isInitialList = peersInfo.length === 0;
            addSystemMessage(`Received peer list update from host.`);
            peersInfo = data.peers; // Update local list
            updateOnlineUsersList(); // Update guest's UI

            // On initial list receipt, connect to other peers
            if (isInitialList) {
                peersInfo.forEach(pInfo => {
                    // Don't connect to self or the host (already connected)
                    if (pInfo.peerId !== peer.id && pInfo.peerId !== hostConnection.peer && !connections.some(c => c.peer === pInfo.peerId)) {
                        addSystemMessage(`Connecting to peer: ${pInfo.username}...`);
                        const peerConn = peer.connect(pInfo.peerId, {
                            metadata: { username: username },
                            reliable: true
                        });
                        // Add connection *only if not already present*
                        if (!connections.some(c => c.peer === peerConn.peer)) {
                            connections.push(peerConn);
                        }
                        setupConnection(peerConn); // Use general setup for peer-to-peer connections
                    }
                });
            }
        } else {
             // Handle other data from host using the general handler
             handleConnectionData(data, hostConnection);
        }
    });

    hostConnection.on('close', () => {
        addSystemMessage('Disconnected from host. Leaving room.');
        leaveRoom(); // Or implement reconnection logic
    });

    hostConnection.on('error', (err) => {
        addSystemMessage(`Host connection error: ${err.type}`);
        leaveRoom(); // Or implement reconnection logic
    });
}


// General setup for any connection (host-guest, guest-guest)
// REMOVE the close/error handlers from here as they are handled specifically
// for host connection and host's perspective on guest connections.
// Guest-to-guest connection close/error doesn't need to trigger list updates,
// as the host's broadcast is the source of truth.
function setupConnection(connection) {
  connection.on('open', () => {
    const peerUsername = connection.metadata?.username || peersInfo.find(p => p.peerId === connection.peer)?.username || 'A user';
    addSystemMessage(`Connection with ${peerUsername} (${connection.peer}) established.`);
  });

  connection.on('data', (data) => {
     handleConnectionData(data, connection); // Use a shared data handler
  });

  // Guest-to-guest close/error handling (optional, mainly for debugging or specific features)
  connection.on('close', () => {
      const closedPeerInfo = peersInfo.find(p => p.peerId === connection.peer);
      const closedUsername = closedPeerInfo?.username || 'A user';
      // Don't update list here, rely on host broadcast
      console.log(`Direct connection with ${closedUsername} (${connection.peer}) closed.`);
      // Remove from connections array if needed for other logic
      connections = connections.filter(conn => conn.peer !== connection.peer);
      // Optionally cleanup media if needed, though host broadcast should handle list update
      // cleanupMediaForPeer(connection.peer, closedUsername);
  });

   connection.on('error', (err) => {
      const errorPeerInfo = peersInfo.find(p => p.peerId === connection.peer);
      const errorUsername = errorPeerInfo?.username || 'A user';
      // Don't update list here, rely on host broadcast
      console.error(`Direct connection error with ${errorUsername} (${connection.peer}): ${err.type}`);
      connections = connections.filter(conn => conn.peer !== connection.peer);
      // Optionally cleanup media
      // cleanupMediaForPeer(connection.peer, errorUsername);
   });
}

// Shared handler for data received on any connection
function handleConnectionData(data, connection) {
    const senderPeerId = connection.peer;
    const senderInfo = peersInfo.find(p => p.peerId === senderPeerId);
    const senderName = data.sender || senderInfo?.username || connection.metadata?.username || 'Unknown';

    if (typeof data === 'object') {
      switch (data.type) {
        case 'message':
          addReceivedMessage(data.text, senderName);
          break;
        case 'system':
          addSystemMessage(data.message);
          break;
        // REMOVE 'newPeer' case - host sends full 'peerList' instead
        // case 'newPeer': ... removed ...
        case 'peerList': // Guest receives updated list from host
            if (!isRoomCreator) { // Only guests should process lists received this way
                addSystemMessage(`Received peer list update from host.`);
                peersInfo = data.peers;
                updateOnlineUsersList();
            }
            break;
        case 'screenShareStarting':
          addSystemMessage(`${senderName} is starting to share their screen...`);
          break;
        case 'screenShareStopped':
          cleanupScreenShare(senderPeerId, senderName);
          break;
        case 'audioShareStarting':
          addSystemMessage(`${senderName} is starting to share audio...`);
          break;
        case 'audioShareStopped':
          cleanupAudioShare(senderPeerId, senderName);
          break;
        case 'file-chunk':
          handleFileChunk(data, senderPeerId);
          break;
        default:
          console.log('Received unknown data object type:', data.type, data);
      }
    } else if (typeof data === 'string') {
       addReceivedMessage(data, senderName);
    } else {
       console.log('Received unexpected data format:', data);
    }
}

// Helper to clean up media if a peer disconnects or stops sharing
function cleanupMediaForPeer(peerId, peerUsername) {
   cleanupScreenShare(peerId, peerUsername, "(disconnected)");
   cleanupAudioShare(peerId, peerUsername, "(disconnected)");
}

function cleanupScreenShare(peerId, peerUsername, reason = "stopped sharing") {
   if (screenSharingPeerId === peerId) {
      document.getElementById('shared-screen').style.display = 'none';
      document.getElementById('shared-screen').srcObject = null;
      document.getElementById('screen-placeholder').style.display = 'flex';
      screenSharingPeerId = null;
      addSystemMessage(`${peerUsername || 'Someone'} ${reason} their screen`);
   }
}

 function cleanupAudioShare(peerId, peerUsername, reason = "stopped sharing") {
   if (audioSharingPeerId === peerId) {
      document.getElementById('shared-audio').style.display = 'none';
      document.getElementById('shared-audio').srcObject = null;
      document.getElementById('audio-placeholder').style.display = 'flex';
      // Ensure visualizer is removed if it exists and belongs to this stream
      const visualizer = document.getElementById('audio-visualizer');
      if (visualizer) visualizer.remove();
      if (audioVisualizerInterval) clearInterval(audioVisualizerInterval);
      if (audioContext) audioContext.close().catch(e => console.error("Error closing audio context:", e));
      audioContext = null;
      audioAnalyser = null;

      audioSharingPeerId = null;
      addSystemMessage(`${peerUsername || 'Someone'} ${reason} their audio`);
   }
}


function leaveRoom() {
  addSystemMessage('Leaving room...');
  // Stop media sharing
  if (isScreenSharing) stopScreenShare(false); // Pass false to prevent broadcast
  if (isAudioSharing) stopAudioShare(false); // Pass false to prevent broadcast

  // Close connections
  connections.forEach(conn => {
    if (conn && conn.close) {
       conn.close();
    }
  });
  connections = [];
  peersInfo = [];

  // Destroy peer object
  if (peer) {
    peer.destroy();
    peer = null;
  }

  // Reset UI
  document.getElementById('setup-card').style.display = 'block';
  document.getElementById('chat-card').style.display = 'none';
  document.getElementById('online-users-panel').style.display = 'none'; // Hide panel
  document.querySelector('.messages').innerHTML = '';
  document.getElementById('room-info').style.display = 'none';
  document.getElementById('username-error').classList.remove('visible');
  document.getElementById('host-username').value = '';
  document.getElementById('guest-username').value = '';
  document.getElementById('room-code-input').value = '';
  document.getElementById('room-code').textContent = 'Not created yet';
  document.getElementById('message').value = '';
  document.getElementById('file-input').value = ''; // Clear file input
  document.getElementById('file-progress').style.display = 'none';


  // Reset media UI elements
  document.getElementById('shared-screen').style.display = 'none';
  document.getElementById('shared-screen').srcObject = null;
  document.getElementById('screen-placeholder').style.display = 'flex';
  document.getElementById('screen-sharing-notice').style.display = 'none';
  document.getElementById('start-share-btn').style.display = 'inline-flex';
  document.getElementById('stop-share-btn').style.display = 'none';

  document.getElementById('shared-audio').style.display = 'none';
  document.getElementById('shared-audio').srcObject = null;
  document.getElementById('audio-placeholder').style.display = 'flex';
  document.getElementById('audio-placeholder').innerHTML = '<div>No audio is being shared</div>'; // Reset placeholder text
  document.getElementById('audio-sharing-notice').style.display = 'none';
  document.getElementById('start-audio-btn').style.display = 'inline-flex';
  document.getElementById('stop-audio-btn').style.display = 'none';
  const visualizer = document.getElementById('audio-visualizer');
  if (visualizer) visualizer.remove();
  if (audioVisualizerInterval) clearInterval(audioVisualizerInterval);
  if (audioContext) audioContext.close().catch(e => console.error("Error closing audio context:", e));
  audioContext = null;
  audioAnalyser = null;


  updateConnectionStatus('disconnected');
  updateOnlineUsersList(); // Clear the list UI
  console.log("Left room and cleaned up.");
}

// Modify stop functions to optionally prevent broadcasting the stop message
// (used when leaving the room)
function stopScreenShare(broadcast = true) {
  if (!isScreenSharing || !localStream) return;

  // Stop all tracks
  localStream.getTracks().forEach(track => track.stop());
  localStream = null;

  // Update UI
  document.getElementById('shared-screen').style.display = 'none';
  document.getElementById('shared-screen').srcObject = null;
  document.getElementById('screen-placeholder').style.display = 'flex';
  document.getElementById('screen-sharing-notice').style.display = 'none';
  document.getElementById('start-share-btn').style.display = 'inline-flex';
  document.getElementById('stop-share-btn').style.display = 'none';

  isScreenSharing = false;


  if (broadcast) {
    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'screenShareStopped',
          peerId: peer.id, // Use peer.id consistently
          username: username
        });
      }
    });
    addSystemMessage('You stopped sharing your screen');
  }
   screenSharingPeerId = null; // Clear regardless of broadcast
}

function stopAudioShare(broadcast = true) {
  if (!isAudioSharing || !audioStream) return;

  // Stop all tracks
  audioStream.getTracks().forEach(track => track.stop());
  audioStream = null;

  // Clean up audio context if it exists
  if (audioContext) {
    clearInterval(audioVisualizerInterval);
    audioContext.close().catch(e => console.error("Error closing audio context:", e));
    audioContext = null;
    audioAnalyser = null;
  }

  // Update UI
  document.getElementById('audio-sharing-notice').style.display = 'none';
  document.getElementById('audio-placeholder').style.display = 'flex';
  document.getElementById('audio-placeholder').innerHTML = '<div>No audio is being shared</div>'; // Reset placeholder text
  document.getElementById('start-audio-btn').style.display = 'inline-flex';
  document.getElementById('stop-audio-btn').style.display = 'none';

  // Remove visualizer if it exists
  const visualizer = document.getElementById('audio-visualizer');
  if (visualizer) {
    visualizer.remove();
  }

  isAudioSharing = false;

  // Notify all peers that audio sharing has stopped
  if (broadcast) {
    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'audioShareStopped',
          peerId: peer.id, // Use peer.id consistently
          username: username
        });
      }
    });
    addSystemMessage('You stopped sharing your audio');
  }
  audioSharingPeerId = null; // Clear regardless of broadcast
}


// --- Other existing functions (sendMessage, addSystemMessage, etc.) ---

function updateOnlineUsersList() {
  const listElement = document.getElementById('online-users-list');
  const panelElement = document.getElementById('online-users-panel');
  listElement.innerHTML = ''; // Clear current list

  if (peersInfo.length > 0) {
    peersInfo.forEach(pInfo => {
      const li = document.createElement('li');
      li.textContent = pInfo.username;
      if (pInfo.peerId === peer.id) {
         const youSpan = document.createElement('span');
         youSpan.className = 'you-indicator';
         youSpan.textContent = '(You)';
         li.appendChild(youSpan);
      }
      listElement.appendChild(li);
    });
    panelElement.style.display = 'block'; // Show the panel
  } else {
    panelElement.style.display = 'none'; // Hide if empty
  }
}

function sendMessage() {
  const message = document.getElementById('message').value.trim();
  if (!message) return;

  if (connections.length > 0) {
    connections.forEach(conn => {
      if (conn.open) {
        conn.send({
          type: 'message',
          text: message,
          sender: username
        });
      }
    });
    addSentMessage(message);
    document.getElementById('message').value = '';
  } else {
    addSystemMessage('Not connected to any peers.');
  }
}

function handleKeyPress(event) {
  if (event.key === 'Enter') {
    sendMessage();
  }
}

function copyRoomCode() {
  const roomCode = document.getElementById('room-code').textContent;
  if (roomCode && roomCode !== 'Not created yet') {
    navigator.clipboard.writeText(roomCode)
      .then(() => addSystemMessage('Room code copied to clipboard!'))
      .catch(err => addSystemMessage('Failed to copy: ' + err));
  }
}

function updateConnectionStatus(status) {
  const statusElement = document.querySelector('.connection-status');
  const statusTextElement = document.getElementById('connection-text');
  statusElement.className = 'connection-status';

  switch(status) {
    case 'connected':
      statusElement.classList.add('status-connected');
      statusTextElement.textContent = 'Connected';
      break;
    case 'connecting':
      statusElement.classList.add('status-disconnected');
      statusTextElement.textContent = 'Connecting...';
      break;
    case 'waiting':
      statusElement.classList.add('status-disconnected');
      statusTextElement.textContent = 'Waiting for someone to join';
      break;
    case 'error':
      statusElement.classList.add('status-disconnected');
      statusTextElement.textContent = 'Connection error';
      break;
    default:
      statusElement.classList.add('status-disconnected');
      statusTextElement.textContent = 'Not connected';
  }
}

function addSystemMessage(text) {
  const messagesEl = document.querySelector('.messages');
  const messageEl = document.createElement('div');
  messageEl.className = 'system-message';
  messageEl.textContent = text;
  messagesEl.appendChild(messageEl);
  scrollToBottom();
}

function addReceivedMessage(text, senderName) {
  const messagesEl = document.querySelector('.messages');
  const messageEl = document.createElement('div');
  messageEl.className = 'message received';

  if (senderName) {
    const senderEl = document.createElement('div');
    senderEl.className = 'sender-name';
    senderEl.textContent = senderName;
    messageEl.appendChild(senderEl);
  }

  const contentEl = document.createElement('div');
  contentEl.textContent = text;
  messageEl.appendChild(contentEl);

  const timeEl = document.createElement('div');
  timeEl.className = 'message-time';
  timeEl.textContent = getCurrentTime();
  messageEl.appendChild(timeEl);

  messagesEl.appendChild(messageEl);
  scrollToBottom();
}

function addSentMessage(text) {
  const messagesEl = document.querySelector('.messages');
  const messageEl = document.createElement('div');
  messageEl.className = 'message sent';

  const contentEl = document.createElement('div');
  contentEl.textContent = text;
  messageEl.appendChild(contentEl);

  const timeEl = document.createElement('div');
  timeEl.className = 'message-time';
  timeEl.textContent = getCurrentTime();
  messageEl.appendChild(timeEl);

  messagesEl.appendChild(messageEl);
  scrollToBottom();
}

function getCurrentTime() {
  const now = new Date();
  let hours = now.getHours();
  let minutes = now.getMinutes();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  hours = hours ? hours : 12;
  minutes = minutes < 10 ? '0' + minutes : minutes;
  return `${hours}:${minutes} ${ampm}`;
}

function scrollToBottom() {
  const container = document.getElementById('messages');
  container.scrollTop = container.scrollHeight;
}
  </script>
</body>
</html>